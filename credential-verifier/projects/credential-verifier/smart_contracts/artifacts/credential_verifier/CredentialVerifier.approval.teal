#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 32 2
    bytecblock 0x61646d696e 0x7265765f 0x151f7c75
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/credential_verifier/contract.py:48
    // self.admin = GlobalState(Txn.sender, key=b"admin")
    bytec_0 // 0x61646d696e
    txn Sender
    app_global_put

main_after_if_else@2:
    // smart_contracts/credential_verifier/contract.py:30
    // class CredentialVerifier(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@13
    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    pushbytess 0x0d69d6d6 0x39f446af 0x1edea6b0 0x46f8ad75 // method "issue_credential(address,string,string,string)uint64", method "transfer_to_student(uint64,address)void", method "get_issuer_info()address", method "revoke_credential(uint64,address)void"
    txna ApplicationArgs 0
    match issue_credential transfer_to_student get_issuer_info revoke_credential
    err

main___algopy_default_create@13:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return


// smart_contracts.credential_verifier.contract.CredentialVerifier.issue_credential[routing]() -> void:
issue_credential:
    // smart_contracts/credential_verifier/contract.py:64
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/credential_verifier/contract.py:81
    // self._assert_admin()
    callsub _assert_admin
    // smart_contracts/credential_verifier/contract.py:83-99
    // # Inner transaction: create the ASA.
    // # .submit() returns an AssetConfigInnerTransaction object.
    // asset_create_txn = itxn.AssetConfig(
    //     total=1,
    //     decimals=0,
    //     default_frozen=False,
    //     unit_name=unit_name.native,
    //     asset_name=asset_name.native,
    //     url=ipfs_url.native,
    //     # Lock the asset: only the contract can manage / freeze / clawback
    //     manager=Global.current_application_address,
    //     freeze=Global.current_application_address,
    //     clawback=Global.current_application_address,
    //     # Reserve to student shows ownership provenance in the ASA metadata
    //     reserve=student_address.native,
    //     fee=0,
    // ).submit()
    itxn_begin
    // smart_contracts/credential_verifier/contract.py:89
    // unit_name=unit_name.native,
    swap
    extract 2 0
    // smart_contracts/credential_verifier/contract.py:90
    // asset_name=asset_name.native,
    uncover 2
    extract 2 0
    // smart_contracts/credential_verifier/contract.py:91
    // url=ipfs_url.native,
    uncover 2
    extract 2 0
    // smart_contracts/credential_verifier/contract.py:92-93
    // # Lock the asset: only the contract can manage / freeze / clawback
    // manager=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/credential_verifier/contract.py:94-95
    // freeze=Global.current_application_address,
    // clawback=Global.current_application_address,
    dupn 2
    uncover 6
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetClawback
    itxn_field ConfigAssetFreeze
    itxn_field ConfigAssetManager
    itxn_field ConfigAssetURL
    itxn_field ConfigAssetName
    itxn_field ConfigAssetUnitName
    // smart_contracts/credential_verifier/contract.py:88
    // default_frozen=False,
    intc_0 // 0
    itxn_field ConfigAssetDefaultFrozen
    // smart_contracts/credential_verifier/contract.py:87
    // decimals=0,
    intc_0 // 0
    itxn_field ConfigAssetDecimals
    // smart_contracts/credential_verifier/contract.py:86
    // total=1,
    intc_1 // 1
    itxn_field ConfigAssetTotal
    // smart_contracts/credential_verifier/contract.py:83-85
    // # Inner transaction: create the ASA.
    // # .submit() returns an AssetConfigInnerTransaction object.
    // asset_create_txn = itxn.AssetConfig(
    pushint 3 // acfg
    itxn_field TypeEnum
    // smart_contracts/credential_verifier/contract.py:98
    // fee=0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/credential_verifier/contract.py:83-99
    // # Inner transaction: create the ASA.
    // # .submit() returns an AssetConfigInnerTransaction object.
    // asset_create_txn = itxn.AssetConfig(
    //     total=1,
    //     decimals=0,
    //     default_frozen=False,
    //     unit_name=unit_name.native,
    //     asset_name=asset_name.native,
    //     url=ipfs_url.native,
    //     # Lock the asset: only the contract can manage / freeze / clawback
    //     manager=Global.current_application_address,
    //     freeze=Global.current_application_address,
    //     clawback=Global.current_application_address,
    //     # Reserve to student shows ownership provenance in the ASA metadata
    //     reserve=student_address.native,
    //     fee=0,
    // ).submit()
    itxn_submit
    itxn CreatedAssetID
    // smart_contracts/credential_verifier/contract.py:104-105
    // # Initialise revocation flag to False
    // self.is_revoked[created_asset_id] = arc4.Bool(False)
    itob
    bytec_1 // 0x7265765f
    dig 1
    concat
    pushbytes 0x00
    box_put
    // smart_contracts/credential_verifier/contract.py:64
    // @abimethod()
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.credential_verifier.contract.CredentialVerifier.transfer_to_student[routing]() -> void:
transfer_to_student:
    // smart_contracts/credential_verifier/contract.py:109
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    pushint 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/credential_verifier/contract.py:121
    // self._assert_admin()
    callsub _assert_admin
    // smart_contracts/credential_verifier/contract.py:123-124
    // # Verify the asset was not already revoked
    // revoked, exists = self.is_revoked.maybe(asset.id)
    dig 1
    itob
    bytec_1 // 0x7265765f
    swap
    concat
    box_get
    // smart_contracts/credential_verifier/contract.py:125
    // assert exists, "Unknown credential asset"
    assert // Unknown credential asset
    // smart_contracts/credential_verifier/contract.py:126
    // assert not revoked.native, "Cannot transfer a revoked credential"
    intc_0 // 0
    getbit
    !
    assert // Cannot transfer a revoked credential
    // smart_contracts/credential_verifier/contract.py:128-133
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_receiver=student.native,
    //     asset_amount=1,
    //     fee=0,
    // ).submit()
    itxn_begin
    // smart_contracts/credential_verifier/contract.py:131
    // asset_amount=1,
    intc_1 // 1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/credential_verifier/contract.py:128
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    // smart_contracts/credential_verifier/contract.py:132
    // fee=0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/credential_verifier/contract.py:128-133
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_receiver=student.native,
    //     asset_amount=1,
    //     fee=0,
    // ).submit()
    itxn_submit
    // smart_contracts/credential_verifier/contract.py:109
    // @abimethod()
    intc_1 // 1
    return


// smart_contracts.credential_verifier.contract.CredentialVerifier.get_issuer_info[routing]() -> void:
get_issuer_info:
    // smart_contracts/credential_verifier/contract.py:143
    // return arc4.Address(self.admin.value)
    intc_0 // 0
    bytec_0 // 0x61646d696e
    app_global_get_ex
    assert // check self.admin exists
    // smart_contracts/credential_verifier/contract.py:135
    // @abimethod(readonly=True)
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.credential_verifier.contract.CredentialVerifier.revoke_credential[routing]() -> void:
revoke_credential:
    // smart_contracts/credential_verifier/contract.py:145
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    pushint 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/credential_verifier/contract.py:159
    // self._assert_admin()
    callsub _assert_admin
    // smart_contracts/credential_verifier/contract.py:161
    // revoked, exists = self.is_revoked.maybe(asset.id)
    dig 1
    itob
    bytec_1 // 0x7265765f
    swap
    concat
    dup
    box_get
    // smart_contracts/credential_verifier/contract.py:162
    // assert exists, "Unknown credential asset"
    assert // Unknown credential asset
    // smart_contracts/credential_verifier/contract.py:163
    // assert not revoked.native, "Credential is already revoked"
    intc_0 // 0
    getbit
    !
    assert // Credential is already revoked
    // smart_contracts/credential_verifier/contract.py:165-171
    // # Step 1 – freeze the student's account for this asset
    // itxn.AssetFreeze(
    //     freeze_asset=asset,
    //     freeze_account=student.native,
    //     frozen=True,
    //     fee=0,
    // ).submit()
    itxn_begin
    // smart_contracts/credential_verifier/contract.py:169
    // frozen=True,
    intc_1 // 1
    itxn_field FreezeAssetFrozen
    dig 1
    itxn_field FreezeAssetAccount
    dig 2
    itxn_field FreezeAsset
    // smart_contracts/credential_verifier/contract.py:165-166
    // # Step 1 – freeze the student's account for this asset
    // itxn.AssetFreeze(
    pushint 5 // afrz
    itxn_field TypeEnum
    // smart_contracts/credential_verifier/contract.py:170
    // fee=0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/credential_verifier/contract.py:165-171
    // # Step 1 – freeze the student's account for this asset
    // itxn.AssetFreeze(
    //     freeze_asset=asset,
    //     freeze_account=student.native,
    //     frozen=True,
    //     fee=0,
    // ).submit()
    itxn_submit
    // smart_contracts/credential_verifier/contract.py:173-180
    // # Step 2 – clawback the asset from the student back to the contract
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_sender=student.native,          # clawback source
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=1,
    //     fee=0,
    // ).submit()
    itxn_begin
    // smart_contracts/credential_verifier/contract.py:177
    // asset_receiver=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/credential_verifier/contract.py:178
    // asset_amount=1,
    intc_1 // 1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    swap
    itxn_field AssetSender
    swap
    itxn_field XferAsset
    // smart_contracts/credential_verifier/contract.py:173-174
    // # Step 2 – clawback the asset from the student back to the contract
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    // smart_contracts/credential_verifier/contract.py:179
    // fee=0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/credential_verifier/contract.py:173-180
    // # Step 2 – clawback the asset from the student back to the contract
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_sender=student.native,          # clawback source
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=1,
    //     fee=0,
    // ).submit()
    itxn_submit
    // smart_contracts/credential_verifier/contract.py:182-183
    // # Step 3 – mark as revoked in box storage (permanent, on-chain record)
    // self.is_revoked[asset.id] = arc4.Bool(True)
    pushbytes 0x80
    box_put
    // smart_contracts/credential_verifier/contract.py:145
    // @abimethod()
    intc_1 // 1
    return


// smart_contracts.credential_verifier.contract.CredentialVerifier._assert_admin() -> void:
_assert_admin:
    // smart_contracts/credential_verifier/contract.py:58
    // assert Txn.sender == self.admin.value, "Only the admin can call this method"
    txn Sender
    intc_0 // 0
    bytec_0 // 0x61646d696e
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Only the admin can call this method
    retsub
