# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": ["NoOp"]}, "methods": [{"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "address", "name": "student_address"}, {"type": "string", "name": "asset_name"}, {"type": "string", "name": "unit_name"}, {"type": "string", "name": "ipfs_url"}], "name": "issue_credential", "returns": {"type": "uint64"}, "desc": "Mint a non-transferable NFT certificate for a student.\nOnly callable by the admin. Sets manager, freeze, and clawback to the contract address so the student can never transfer or sell the credential.\nReturns the newly created Asset ID.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "asset"}, {"type": "address", "name": "student"}], "name": "transfer_to_student", "returns": {"type": "void"}, "desc": "Transfer the minted NFT from the contract to the student.\nPre-condition: the student must have opted-in to the ASA beforehand. Only callable by the admin.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "get_issuer_info", "returns": {"type": "address"}, "desc": "Return the university admin address.\nReadonly (no state change). Frontends can call this to verify the issuer of any certificate minted by this contract.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "asset"}, {"type": "address", "name": "student"}], "name": "revoke_credential", "returns": {"type": "void"}, "desc": "Revoke a credential:\n1. Freeze the student's holding via an inner AssetFreeze txn.   2. Clawback the asset back to the contract via an inner AssetTransfer.   3. Mark the credential as revoked in Box storage.\nOnly callable by the admin.", "events": [], "readonly": false, "recommendations": {}}], "name": "CredentialVerifier", "state": {"keys": {"box": {}, "global": {"admin": {"key": "YWRtaW4=", "keyType": "AVMBytes", "valueType": "address"}}, "local": {}}, "maps": {"box": {"is_revoked": {"keyType": "uint64", "valueType": "bool", "prefix": "cmV2Xw=="}}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 1, "ints": 0}, "local": {"bytes": 0, "ints": 0}}}, "structs": {}, "byteCode": {"approval": "CyAEAAEgAiYDBWFkbWluBHJldl8EFR98dTEYQAAEKDEAZzEbQQArMRkURDEYRIIEBA1p1tYEOfRGrwQe3qawBEb4rXU2GgCOBAAJAIAAswC9ADEZFDEYFBBDNhoBSRUkEkQ2GgJJIlklCEsBFRJENhoDSSJZJQhLARUSRDYaBEkiWSUISwEVEkSIANSxTFcCAE8CVwIATwJXAgAyCkcCTwayKrIssiuyKbInsiayJSKyJCKyIyOyIoEDshAisgGztDwWKUsBUIABAL8qTFCwI0M2GgFJFYEIEkQXNhoCSRUkEkSIAHpLARYpTFC+RCJTFESxI7ISshSyEYEEshAisgGzI0MiKGVEKkxQsCNDNhoBSRWBCBJEFzYaAkkVJBJEiAA9SwEWKUxQSb5EIlMURLEjsi9LAbIuSwKyLYEFshAisgGzsTIKI7ISshRMshNMshGBBLIQIrIBs4ABgL8jQzEAIihlRBJEiQ==", "clear": "C4EBQw=="}, "events": [], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAwIDEgMzIgMgogICAgYnl0ZWNibG9jayAweDYxNjQ2ZDY5NmUgMHg3MjY1NzY1ZiAweDE1MWY3Yzc1CiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYm56IG1haW5fYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvY3JlZGVudGlhbF92ZXJpZmllci9jb250cmFjdC5weTo0OAogICAgLy8gc2VsZi5hZG1pbiA9IEdsb2JhbFN0YXRlKFR4bi5zZW5kZXIsIGtleT1iImFkbWluIikKICAgIGJ5dGVjXzAgLy8gMHg2MTY0NmQ2OTZlCiAgICB0eG4gU2VuZGVyCiAgICBhcHBfZ2xvYmFsX3B1dAoKbWFpbl9hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY3JlZGVudGlhbF92ZXJpZmllci9jb250cmFjdC5weTozMAogICAgLy8gY2xhc3MgQ3JlZGVudGlhbFZlcmlmaWVyKEFSQzRDb250cmFjdCk6CiAgICB0eG4gTnVtQXBwQXJncwogICAgYnogbWFpbl9fX2FsZ29weV9kZWZhdWx0X2NyZWF0ZUAxMwogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0CiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0CiAgICBwdXNoYnl0ZXNzIDB4MGQ2OWQ2ZDYgMHgzOWY0NDZhZiAweDFlZGVhNmIwIDB4NDZmOGFkNzUgLy8gbWV0aG9kICJpc3N1ZV9jcmVkZW50aWFsKGFkZHJlc3Msc3RyaW5nLHN0cmluZyxzdHJpbmcpdWludDY0IiwgbWV0aG9kICJ0cmFuc2Zlcl90b19zdHVkZW50KHVpbnQ2NCxhZGRyZXNzKXZvaWQiLCBtZXRob2QgImdldF9pc3N1ZXJfaW5mbygpYWRkcmVzcyIsIG1ldGhvZCAicmV2b2tlX2NyZWRlbnRpYWwodWludDY0LGFkZHJlc3Mpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIGlzc3VlX2NyZWRlbnRpYWwgdHJhbnNmZXJfdG9fc3R1ZGVudCBnZXRfaXNzdWVyX2luZm8gcmV2b2tlX2NyZWRlbnRpYWwKICAgIGVycgoKbWFpbl9fX2FsZ29weV9kZWZhdWx0X2NyZWF0ZUAxMzoKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICAmJgogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmNyZWRlbnRpYWxfdmVyaWZpZXIuY29udHJhY3QuQ3JlZGVudGlhbFZlcmlmaWVyLmlzc3VlX2NyZWRlbnRpYWxbcm91dGluZ10oKSAtPiB2b2lkOgppc3N1ZV9jcmVkZW50aWFsOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NyZWRlbnRpYWxfdmVyaWZpZXIvY29udHJhY3QucHk6NjQKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMzI+CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICAvLyBzbWFydF9jb250cmFjdHMvY3JlZGVudGlhbF92ZXJpZmllci9jb250cmFjdC5weTo4MQogICAgLy8gc2VsZi5fYXNzZXJ0X2FkbWluKCkKICAgIGNhbGxzdWIgX2Fzc2VydF9hZG1pbgogICAgLy8gc21hcnRfY29udHJhY3RzL2NyZWRlbnRpYWxfdmVyaWZpZXIvY29udHJhY3QucHk6ODMtOTkKICAgIC8vICMgSW5uZXIgdHJhbnNhY3Rpb246IGNyZWF0ZSB0aGUgQVNBLgogICAgLy8gIyAuc3VibWl0KCkgcmV0dXJucyBhbiBBc3NldENvbmZpZ0lubmVyVHJhbnNhY3Rpb24gb2JqZWN0LgogICAgLy8gYXNzZXRfY3JlYXRlX3R4biA9IGl0eG4uQXNzZXRDb25maWcoCiAgICAvLyAgICAgdG90YWw9MSwKICAgIC8vICAgICBkZWNpbWFscz0wLAogICAgLy8gICAgIGRlZmF1bHRfZnJvemVuPUZhbHNlLAogICAgLy8gICAgIHVuaXRfbmFtZT11bml0X25hbWUubmF0aXZlLAogICAgLy8gICAgIGFzc2V0X25hbWU9YXNzZXRfbmFtZS5uYXRpdmUsCiAgICAvLyAgICAgdXJsPWlwZnNfdXJsLm5hdGl2ZSwKICAgIC8vICAgICAjIExvY2sgdGhlIGFzc2V0OiBvbmx5IHRoZSBjb250cmFjdCBjYW4gbWFuYWdlIC8gZnJlZXplIC8gY2xhd2JhY2sKICAgIC8vICAgICBtYW5hZ2VyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgZnJlZXplPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgY2xhd2JhY2s9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICAjIFJlc2VydmUgdG8gc3R1ZGVudCBzaG93cyBvd25lcnNoaXAgcHJvdmVuYW5jZSBpbiB0aGUgQVNBIG1ldGFkYXRhCiAgICAvLyAgICAgcmVzZXJ2ZT1zdHVkZW50X2FkZHJlc3MubmF0aXZlLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2NyZWRlbnRpYWxfdmVyaWZpZXIvY29udHJhY3QucHk6ODkKICAgIC8vIHVuaXRfbmFtZT11bml0X25hbWUubmF0aXZlLAogICAgc3dhcAogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjkwCiAgICAvLyBhc3NldF9uYW1lPWFzc2V0X25hbWUubmF0aXZlLAogICAgdW5jb3ZlciAyCiAgICBleHRyYWN0IDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2NyZWRlbnRpYWxfdmVyaWZpZXIvY29udHJhY3QucHk6OTEKICAgIC8vIHVybD1pcGZzX3VybC5uYXRpdmUsCiAgICB1bmNvdmVyIDIKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvY3JlZGVudGlhbF92ZXJpZmllci9jb250cmFjdC5weTo5Mi05MwogICAgLy8gIyBMb2NrIHRoZSBhc3NldDogb25seSB0aGUgY29udHJhY3QgY2FuIG1hbmFnZSAvIGZyZWV6ZSAvIGNsYXdiYWNrCiAgICAvLyBtYW5hZ2VyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2NyZWRlbnRpYWxfdmVyaWZpZXIvY29udHJhY3QucHk6OTQtOTUKICAgIC8vIGZyZWV6ZT1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gY2xhd2JhY2s9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIGR1cG4gMgogICAgdW5jb3ZlciA2CiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0UmVzZXJ2ZQogICAgaXR4bl9maWVsZCBDb25maWdBc3NldENsYXdiYWNrCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RnJlZXplCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0TWFuYWdlcgogICAgaXR4bl9maWVsZCBDb25maWdBc3NldFVSTAogICAgaXR4bl9maWVsZCBDb25maWdBc3NldE5hbWUKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRVbml0TmFtZQogICAgLy8gc21hcnRfY29udHJhY3RzL2NyZWRlbnRpYWxfdmVyaWZpZXIvY29udHJhY3QucHk6ODgKICAgIC8vIGRlZmF1bHRfZnJvemVuPUZhbHNlLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXREZWZhdWx0RnJvemVuCiAgICAvLyBzbWFydF9jb250cmFjdHMvY3JlZGVudGlhbF92ZXJpZmllci9jb250cmFjdC5weTo4NwogICAgLy8gZGVjaW1hbHM9MCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RGVjaW1hbHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5Ojg2CiAgICAvLyB0b3RhbD0xLAogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRUb3RhbAogICAgLy8gc21hcnRfY29udHJhY3RzL2NyZWRlbnRpYWxfdmVyaWZpZXIvY29udHJhY3QucHk6ODMtODUKICAgIC8vICMgSW5uZXIgdHJhbnNhY3Rpb246IGNyZWF0ZSB0aGUgQVNBLgogICAgLy8gIyAuc3VibWl0KCkgcmV0dXJucyBhbiBBc3NldENvbmZpZ0lubmVyVHJhbnNhY3Rpb24gb2JqZWN0LgogICAgLy8gYXNzZXRfY3JlYXRlX3R4biA9IGl0eG4uQXNzZXRDb25maWcoCiAgICBwdXNoaW50IDMgLy8gYWNmZwogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2NyZWRlbnRpYWxfdmVyaWZpZXIvY29udHJhY3QucHk6OTgKICAgIC8vIGZlZT0wLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvY3JlZGVudGlhbF92ZXJpZmllci9jb250cmFjdC5weTo4My05OQogICAgLy8gIyBJbm5lciB0cmFuc2FjdGlvbjogY3JlYXRlIHRoZSBBU0EuCiAgICAvLyAjIC5zdWJtaXQoKSByZXR1cm5zIGFuIEFzc2V0Q29uZmlnSW5uZXJUcmFuc2FjdGlvbiBvYmplY3QuCiAgICAvLyBhc3NldF9jcmVhdGVfdHhuID0gaXR4bi5Bc3NldENvbmZpZygKICAgIC8vICAgICB0b3RhbD0xLAogICAgLy8gICAgIGRlY2ltYWxzPTAsCiAgICAvLyAgICAgZGVmYXVsdF9mcm96ZW49RmFsc2UsCiAgICAvLyAgICAgdW5pdF9uYW1lPXVuaXRfbmFtZS5uYXRpdmUsCiAgICAvLyAgICAgYXNzZXRfbmFtZT1hc3NldF9uYW1lLm5hdGl2ZSwKICAgIC8vICAgICB1cmw9aXBmc191cmwubmF0aXZlLAogICAgLy8gICAgICMgTG9jayB0aGUgYXNzZXQ6IG9ubHkgdGhlIGNvbnRyYWN0IGNhbiBtYW5hZ2UgLyBmcmVlemUgLyBjbGF3YmFjawogICAgLy8gICAgIG1hbmFnZXI9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICBmcmVlemU9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICBjbGF3YmFjaz1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgICMgUmVzZXJ2ZSB0byBzdHVkZW50IHNob3dzIG93bmVyc2hpcCBwcm92ZW5hbmNlIGluIHRoZSBBU0EgbWV0YWRhdGEKICAgIC8vICAgICByZXNlcnZlPXN0dWRlbnRfYWRkcmVzcy5uYXRpdmUsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBDcmVhdGVkQXNzZXRJRAogICAgLy8gc21hcnRfY29udHJhY3RzL2NyZWRlbnRpYWxfdmVyaWZpZXIvY29udHJhY3QucHk6MTA0LTEwNQogICAgLy8gIyBJbml0aWFsaXNlIHJldm9jYXRpb24gZmxhZyB0byBGYWxzZQogICAgLy8gc2VsZi5pc19yZXZva2VkW2NyZWF0ZWRfYXNzZXRfaWRdID0gYXJjNC5Cb29sKEZhbHNlKQogICAgaXRvYgogICAgYnl0ZWNfMSAvLyAweDcyNjU3NjVmCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBwdXNoYnl0ZXMgMHgwMAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2NyZWRlbnRpYWxfdmVyaWZpZXIvY29udHJhY3QucHk6NjQKICAgIC8vIEBhYmltZXRob2QoKQogICAgYnl0ZWNfMiAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jcmVkZW50aWFsX3ZlcmlmaWVyLmNvbnRyYWN0LkNyZWRlbnRpYWxWZXJpZmllci50cmFuc2Zlcl90b19zdHVkZW50W3JvdXRpbmddKCkgLT4gdm9pZDoKdHJhbnNmZXJfdG9fc3R1ZGVudDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjEwOQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMzI+CiAgICAvLyBzbWFydF9jb250cmFjdHMvY3JlZGVudGlhbF92ZXJpZmllci9jb250cmFjdC5weToxMjEKICAgIC8vIHNlbGYuX2Fzc2VydF9hZG1pbigpCiAgICBjYWxsc3ViIF9hc3NlcnRfYWRtaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjEyMy0xMjQKICAgIC8vICMgVmVyaWZ5IHRoZSBhc3NldCB3YXMgbm90IGFscmVhZHkgcmV2b2tlZAogICAgLy8gcmV2b2tlZCwgZXhpc3RzID0gc2VsZi5pc19yZXZva2VkLm1heWJlKGFzc2V0LmlkKQogICAgZGlnIDEKICAgIGl0b2IKICAgIGJ5dGVjXzEgLy8gMHg3MjY1NzY1ZgogICAgc3dhcAogICAgY29uY2F0CiAgICBib3hfZ2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY3JlZGVudGlhbF92ZXJpZmllci9jb250cmFjdC5weToxMjUKICAgIC8vIGFzc2VydCBleGlzdHMsICJVbmtub3duIGNyZWRlbnRpYWwgYXNzZXQiCiAgICBhc3NlcnQgLy8gVW5rbm93biBjcmVkZW50aWFsIGFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY3JlZGVudGlhbF92ZXJpZmllci9jb250cmFjdC5weToxMjYKICAgIC8vIGFzc2VydCBub3QgcmV2b2tlZC5uYXRpdmUsICJDYW5ub3QgdHJhbnNmZXIgYSByZXZva2VkIGNyZWRlbnRpYWwiCiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICAhCiAgICBhc3NlcnQgLy8gQ2Fubm90IHRyYW5zZmVyIGEgcmV2b2tlZCBjcmVkZW50aWFsCiAgICAvLyBzbWFydF9jb250cmFjdHMvY3JlZGVudGlhbF92ZXJpZmllci9jb250cmFjdC5weToxMjgtMTMzCiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1zdHVkZW50Lm5hdGl2ZSwKICAgIC8vICAgICBhc3NldF9hbW91bnQ9MSwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjEzMQogICAgLy8gYXNzZXRfYW1vdW50PTEsCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL2NyZWRlbnRpYWxfdmVyaWZpZXIvY29udHJhY3QucHk6MTI4CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICBwdXNoaW50IDQgLy8gYXhmZXIKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjEzMgogICAgLy8gZmVlPTAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjEyOC0xMzMKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXN0dWRlbnQubmF0aXZlLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD0xLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjEwOQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmNyZWRlbnRpYWxfdmVyaWZpZXIuY29udHJhY3QuQ3JlZGVudGlhbFZlcmlmaWVyLmdldF9pc3N1ZXJfaW5mb1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmdldF9pc3N1ZXJfaW5mbzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjE0MwogICAgLy8gcmV0dXJuIGFyYzQuQWRkcmVzcyhzZWxmLmFkbWluLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gMHg2MTY0NmQ2OTZlCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYWRtaW4gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvY3JlZGVudGlhbF92ZXJpZmllci9jb250cmFjdC5weToxMzUKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzIgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuY3JlZGVudGlhbF92ZXJpZmllci5jb250cmFjdC5DcmVkZW50aWFsVmVyaWZpZXIucmV2b2tlX2NyZWRlbnRpYWxbcm91dGluZ10oKSAtPiB2b2lkOgpyZXZva2VfY3JlZGVudGlhbDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjE0NQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMzI+CiAgICAvLyBzbWFydF9jb250cmFjdHMvY3JlZGVudGlhbF92ZXJpZmllci9jb250cmFjdC5weToxNTkKICAgIC8vIHNlbGYuX2Fzc2VydF9hZG1pbigpCiAgICBjYWxsc3ViIF9hc3NlcnRfYWRtaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjE2MQogICAgLy8gcmV2b2tlZCwgZXhpc3RzID0gc2VsZi5pc19yZXZva2VkLm1heWJlKGFzc2V0LmlkKQogICAgZGlnIDEKICAgIGl0b2IKICAgIGJ5dGVjXzEgLy8gMHg3MjY1NzY1ZgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9nZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjE2MgogICAgLy8gYXNzZXJ0IGV4aXN0cywgIlVua25vd24gY3JlZGVudGlhbCBhc3NldCIKICAgIGFzc2VydCAvLyBVbmtub3duIGNyZWRlbnRpYWwgYXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjE2MwogICAgLy8gYXNzZXJ0IG5vdCByZXZva2VkLm5hdGl2ZSwgIkNyZWRlbnRpYWwgaXMgYWxyZWFkeSByZXZva2VkIgogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgIQogICAgYXNzZXJ0IC8vIENyZWRlbnRpYWwgaXMgYWxyZWFkeSByZXZva2VkCiAgICAvLyBzbWFydF9jb250cmFjdHMvY3JlZGVudGlhbF92ZXJpZmllci9jb250cmFjdC5weToxNjUtMTcxCiAgICAvLyAjIFN0ZXAgMSDigJMgZnJlZXplIHRoZSBzdHVkZW50J3MgYWNjb3VudCBmb3IgdGhpcyBhc3NldAogICAgLy8gaXR4bi5Bc3NldEZyZWV6ZSgKICAgIC8vICAgICBmcmVlemVfYXNzZXQ9YXNzZXQsCiAgICAvLyAgICAgZnJlZXplX2FjY291bnQ9c3R1ZGVudC5uYXRpdmUsCiAgICAvLyAgICAgZnJvemVuPVRydWUsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvY3JlZGVudGlhbF92ZXJpZmllci9jb250cmFjdC5weToxNjkKICAgIC8vIGZyb3plbj1UcnVlLAogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgRnJlZXplQXNzZXRGcm96ZW4KICAgIGRpZyAxCiAgICBpdHhuX2ZpZWxkIEZyZWV6ZUFzc2V0QWNjb3VudAogICAgZGlnIDIKICAgIGl0eG5fZmllbGQgRnJlZXplQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjE2NS0xNjYKICAgIC8vICMgU3RlcCAxIOKAkyBmcmVlemUgdGhlIHN0dWRlbnQncyBhY2NvdW50IGZvciB0aGlzIGFzc2V0CiAgICAvLyBpdHhuLkFzc2V0RnJlZXplKAogICAgcHVzaGludCA1IC8vIGFmcnoKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjE3MAogICAgLy8gZmVlPTAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjE2NS0xNzEKICAgIC8vICMgU3RlcCAxIOKAkyBmcmVlemUgdGhlIHN0dWRlbnQncyBhY2NvdW50IGZvciB0aGlzIGFzc2V0CiAgICAvLyBpdHhuLkFzc2V0RnJlZXplKAogICAgLy8gICAgIGZyZWV6ZV9hc3NldD1hc3NldCwKICAgIC8vICAgICBmcmVlemVfYWNjb3VudD1zdHVkZW50Lm5hdGl2ZSwKICAgIC8vICAgICBmcm96ZW49VHJ1ZSwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY3JlZGVudGlhbF92ZXJpZmllci9jb250cmFjdC5weToxNzMtMTgwCiAgICAvLyAjIFN0ZXAgMiDigJMgY2xhd2JhY2sgdGhlIGFzc2V0IGZyb20gdGhlIHN0dWRlbnQgYmFjayB0byB0aGUgY29udHJhY3QKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3NlbmRlcj1zdHVkZW50Lm5hdGl2ZSwgICAgICAgICAgIyBjbGF3YmFjayBzb3VyY2UKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD0xLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2NyZWRlbnRpYWxfdmVyaWZpZXIvY29udHJhY3QucHk6MTc3CiAgICAvLyBhc3NldF9yZWNlaXZlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjE3OAogICAgLy8gYXNzZXRfYW1vdW50PTEsCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFzc2V0U2VuZGVyCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL2NyZWRlbnRpYWxfdmVyaWZpZXIvY29udHJhY3QucHk6MTczLTE3NAogICAgLy8gIyBTdGVwIDIg4oCTIGNsYXdiYWNrIHRoZSBhc3NldCBmcm9tIHRoZSBzdHVkZW50IGJhY2sgdG8gdGhlIGNvbnRyYWN0CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICBwdXNoaW50IDQgLy8gYXhmZXIKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjE3OQogICAgLy8gZmVlPTAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jcmVkZW50aWFsX3ZlcmlmaWVyL2NvbnRyYWN0LnB5OjE3My0xODAKICAgIC8vICMgU3RlcCAyIOKAkyBjbGF3YmFjayB0aGUgYXNzZXQgZnJvbSB0aGUgc3R1ZGVudCBiYWNrIHRvIHRoZSBjb250cmFjdAogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIHhmZXJfYXNzZXQ9YXNzZXQsCiAgICAvLyAgICAgYXNzZXRfc2VuZGVyPXN0dWRlbnQubmF0aXZlLCAgICAgICAgICAjIGNsYXdiYWNrIHNvdXJjZQogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PTEsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2NyZWRlbnRpYWxfdmVyaWZpZXIvY29udHJhY3QucHk6MTgyLTE4MwogICAgLy8gIyBTdGVwIDMg4oCTIG1hcmsgYXMgcmV2b2tlZCBpbiBib3ggc3RvcmFnZSAocGVybWFuZW50LCBvbi1jaGFpbiByZWNvcmQpCiAgICAvLyBzZWxmLmlzX3Jldm9rZWRbYXNzZXQuaWRdID0gYXJjNC5Cb29sKFRydWUpCiAgICBwdXNoYnl0ZXMgMHg4MAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2NyZWRlbnRpYWxfdmVyaWZpZXIvY29udHJhY3QucHk6MTQ1CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuY3JlZGVudGlhbF92ZXJpZmllci5jb250cmFjdC5DcmVkZW50aWFsVmVyaWZpZXIuX2Fzc2VydF9hZG1pbigpIC0+IHZvaWQ6Cl9hc3NlcnRfYWRtaW46CiAgICAvLyBzbWFydF9jb250cmFjdHMvY3JlZGVudGlhbF92ZXJpZmllci9jb250cmFjdC5weTo1OAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gc2VsZi5hZG1pbi52YWx1ZSwgIk9ubHkgdGhlIGFkbWluIGNhbiBjYWxsIHRoaXMgbWV0aG9kIgogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gMHg2MTY0NmQ2OTZlCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYWRtaW4gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgdGhlIGFkbWluIGNhbiBjYWxsIHRoaXMgbWV0aG9kCiAgICByZXRzdWIK", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMQogICAgcmV0dXJuCg=="}, "sourceInfo": {"approval": {"pcOffsetMethod": "none", "sourceInfo": [{"pc": [241], "errorMessage": "Cannot transfer a revoked credential"}, {"pc": [303], "errorMessage": "Credential is already revoked"}, {"pc": [359], "errorMessage": "Only the admin can call this method"}, {"pc": [237, 299], "errorMessage": "Unknown credential asset"}, {"pc": [263, 357], "errorMessage": "check self.admin exists"}, {"pc": [103, 116, 129], "errorMessage": "invalid array length header"}, {"pc": [110, 123, 136], "errorMessage": "invalid number of bytes for arc4.dynamic_array<arc4.uint8>"}, {"pc": [97, 226, 287], "errorMessage": "invalid number of bytes for arc4.static_array<arc4.uint8, 32>"}, {"pc": [217, 278], "errorMessage": "invalid number of bytes for arc4.uint64"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True, kw_only=True)
class IssueCredentialArgs:
    """Dataclass for issue_credential arguments"""
    student_address: str
    asset_name: str
    unit_name: str
    ipfs_url: str

    @property
    def abi_method_signature(self) -> str:
        return "issue_credential(address,string,string,string)uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class TransferToStudentArgs:
    """Dataclass for transfer_to_student arguments"""
    asset: int
    student: str

    @property
    def abi_method_signature(self) -> str:
        return "transfer_to_student(uint64,address)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class RevokeCredentialArgs:
    """Dataclass for revoke_credential arguments"""
    asset: int
    student: str

    @property
    def abi_method_signature(self) -> str:
        return "revoke_credential(uint64,address)void"


class CredentialVerifierParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def issue_credential(
        self,
        args: tuple[str, str, str, str] | IssueCredentialArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "issue_credential(address,string,string,string)uint64",
            "args": method_args,
        }))

    def transfer_to_student(
        self,
        args: tuple[int, str] | TransferToStudentArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "transfer_to_student(uint64,address)void",
            "args": method_args,
        }))

    def get_issuer_info(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_issuer_info()address",
        }))

    def revoke_credential(
        self,
        args: tuple[int, str] | RevokeCredentialArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "revoke_credential(uint64,address)void",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class CredentialVerifierCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def issue_credential(
        self,
        args: tuple[str, str, str, str] | IssueCredentialArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "issue_credential(address,string,string,string)uint64",
            "args": method_args,
        }))

    def transfer_to_student(
        self,
        args: tuple[int, str] | TransferToStudentArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "transfer_to_student(uint64,address)void",
            "args": method_args,
        }))

    def get_issuer_info(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_issuer_info()address",
        }))

    def revoke_credential(
        self,
        args: tuple[int, str] | RevokeCredentialArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "revoke_credential(uint64,address)void",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class CredentialVerifierSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def issue_credential(
        self,
        args: tuple[str, str, str, str] | IssueCredentialArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "issue_credential(address,string,string,string)uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def transfer_to_student(
        self,
        args: tuple[int, str] | TransferToStudentArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "transfer_to_student(uint64,address)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def get_issuer_info(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_issuer_info()address",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def revoke_credential(
        self,
        args: tuple[int, str] | RevokeCredentialArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "revoke_credential(uint64,address)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class GlobalStateValue(typing.TypedDict):
    """Shape of global_state state key values"""
    admin: str

class CredentialVerifierState:
    """Methods to access state for the current CredentialVerifier app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def global_state(
        self
    ) -> "_GlobalState":
            """Methods to access global_state for the current app"""
            return _GlobalState(self.app_client)

    @property
    def box(
        self
    ) -> "_BoxState":
            """Methods to access box for the current app"""
            return _BoxState(self.app_client)

class _GlobalState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> GlobalStateValue:
        """Get all current keyed values from global_state state"""
        result = self.app_client.state.global_state.get_all()
        if not result:
            return typing.cast(GlobalStateValue, {})

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.global_state.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return typing.cast(GlobalStateValue, converted)

    @property
    def admin(self) -> str:
        """Get the current value of the admin key in global_state state"""
        value = self.app_client.state.global_state.get_value("admin")
        if isinstance(value, dict) and "address" in self._struct_classes:
            return _init_dataclass(self._struct_classes["address"], value)  # type: ignore
        return typing.cast(str, value)

class _BoxState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> dict[str, typing.Any]:
        """Get all current keyed values from box state"""
        result = self.app_client.state.box.get_all()
        if not result:
            return {}

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.box.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return converted

    @property
    def is_revoked(self) -> "_MapState[int, bool]":
        """Get values from the is_revoked map in box state"""
        return _MapState(
            self.app_client.state.box,
            "is_revoked",
            None
        )

_KeyType = typing.TypeVar("_KeyType")
_ValueType = typing.TypeVar("_ValueType")

class _AppClientStateMethodsProtocol(typing.Protocol):
    def get_map(self, map_name: str) -> dict[typing.Any, typing.Any]:
        ...
    def get_map_value(self, map_name: str, key: typing.Any) -> typing.Any | None:
        ...

class _MapState(typing.Generic[_KeyType, _ValueType]):
    """Generic class for accessing state maps with strongly typed keys and values"""

    def __init__(self, state_accessor: _AppClientStateMethodsProtocol, map_name: str,
                struct_class: typing.Type[_ValueType] | None = None):
        self._state_accessor = state_accessor
        self._map_name = map_name
        self._struct_class = struct_class

    def get_map(self) -> dict[_KeyType, _ValueType]:
        """Get all current values in the map"""
        result = self._state_accessor.get_map(self._map_name)
        if self._struct_class and result:
            return {k: _init_dataclass(self._struct_class, v) if isinstance(v, dict) else v
                    for k, v in result.items()}  # type: ignore
        return typing.cast(dict[_KeyType, _ValueType], result or {})

    def get_value(self, key: _KeyType) -> _ValueType | None:
        """Get a value from the map by key"""
        key_value = dataclasses.asdict(key) if dataclasses.is_dataclass(key) else key  # type: ignore
        value = self._state_accessor.get_map_value(self._map_name, key_value)
        if value is not None and self._struct_class and isinstance(value, dict):
            return _init_dataclass(self._struct_class, value)  # type: ignore
        return typing.cast(_ValueType | None, value)


class CredentialVerifierClient:
    """Client for interacting with CredentialVerifier smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = CredentialVerifierParams(self.app_client)
        self.create_transaction = CredentialVerifierCreateTransactionParams(self.app_client)
        self.send = CredentialVerifierSend(self.app_client)
        self.state = CredentialVerifierState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "CredentialVerifierClient":
        return CredentialVerifierClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "CredentialVerifierClient":
        return CredentialVerifierClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "CredentialVerifierClient":
        return CredentialVerifierClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "CredentialVerifierComposer":
        return CredentialVerifierComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["issue_credential(address,string,string,string)uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["transfer_to_student(uint64,address)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_issuer_info()address"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["revoke_credential(uint64,address)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None | int | str:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class CredentialVerifierBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):
    """Parameters for creating CredentialVerifier contract with bare calls"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:
        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)

class CredentialVerifierFactory(algokit_utils.TypedAppFactoryProtocol[CredentialVerifierBareCallCreateParams, None, None]):
    """Factory for deploying and managing CredentialVerifierClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = CredentialVerifierFactoryParams(self.app_factory)
        self.create_transaction = CredentialVerifierFactoryCreateTransaction(self.app_factory)
        self.send = CredentialVerifierFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: CredentialVerifierBareCallCreateParams | None = None,
        update_params: None = None,
        delete_params: None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[CredentialVerifierClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return CredentialVerifierClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> CredentialVerifierClient:
        """Get an app client by creator address and name"""
        return CredentialVerifierClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> CredentialVerifierClient:
        """Get an app client by app ID"""
        return CredentialVerifierClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class CredentialVerifierFactoryParams:
    """Parameters for creating transactions for CredentialVerifier contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = CredentialVerifierFactoryCreateParams(app_factory)
        self.update = CredentialVerifierFactoryUpdateParams(app_factory)
        self.delete = CredentialVerifierFactoryDeleteParams(app_factory)

class CredentialVerifierFactoryCreateParams:
    """Parameters for 'create' operations of CredentialVerifier contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def issue_credential(
        self,
        args: tuple[str, str, str, str] | IssueCredentialArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the issue_credential(address,string,string,string)uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "issue_credential(address,string,string,string)uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def transfer_to_student(
        self,
        args: tuple[int, str] | TransferToStudentArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the transfer_to_student(uint64,address)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "transfer_to_student(uint64,address)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def get_issuer_info(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_issuer_info()address ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_issuer_info()address",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def revoke_credential(
        self,
        args: tuple[int, str] | RevokeCredentialArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the revoke_credential(uint64,address)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "revoke_credential(uint64,address)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

class CredentialVerifierFactoryUpdateParams:
    """Parameters for 'update' operations of CredentialVerifier contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class CredentialVerifierFactoryDeleteParams:
    """Parameters for 'delete' operations of CredentialVerifier contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class CredentialVerifierFactoryCreateTransaction:
    """Create transactions for CredentialVerifier contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = CredentialVerifierFactoryCreateTransactionCreate(app_factory)


class CredentialVerifierFactoryCreateTransactionCreate:
    """Create new instances of CredentialVerifier contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class CredentialVerifierFactorySend:
    """Send calls to CredentialVerifier contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = CredentialVerifierFactorySendCreate(app_factory)


class CredentialVerifierFactorySendCreate:
    """Send create calls to CredentialVerifier contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[CredentialVerifierClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return CredentialVerifierClient(result[0]), result[1]


class CredentialVerifierComposer:
    """Composer for creating transaction groups for CredentialVerifier contract calls"""

    def __init__(self, client: "CredentialVerifierClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    def issue_credential(
        self,
        args: tuple[str, str, str, str] | IssueCredentialArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CredentialVerifierComposer":
        self._composer.add_app_call_method_call(
            self.client.params.issue_credential(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "issue_credential(address,string,string,string)uint64", v
            )
        )
        return self

    def transfer_to_student(
        self,
        args: tuple[int, str] | TransferToStudentArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CredentialVerifierComposer":
        self._composer.add_app_call_method_call(
            self.client.params.transfer_to_student(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "transfer_to_student(uint64,address)void", v
            )
        )
        return self

    def get_issuer_info(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CredentialVerifierComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_issuer_info(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_issuer_info()address", v
            )
        )
        return self

    def revoke_credential(
        self,
        args: tuple[int, str] | RevokeCredentialArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CredentialVerifierComposer":
        self._composer.add_app_call_method_call(
            self.client.params.revoke_credential(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "revoke_credential(uint64,address)void", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "CredentialVerifierComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "CredentialVerifierComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)
